<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Map Controls with All L.icon Icons</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
  <!-- Leaflet PolylineDecorator JS (Add this AFTER Leaflet) -->
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>

  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
    }

    #map {
      height: 100vh;
      width: 100vw;
    }

    .vertical-control {
      background: white;
      box-shadow: 0 1px 8px rgba(0, 0, 0, 0.22);
      border-radius: 10px;
      padding: 4px 6px;
      user-select: none;
      display: flex;
      flex-direction: row;
      gap: 8px;
      align-items: flex-end;
      position: absolute;
      left: 50%;
      bottom: 30px;
      transform: translateX(-50%);
      z-index: 1001;
      justify-content: center;
    }

    .control-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 60px;
      width: 60px;
      flex: 1 1 0;
    }

    .vertical-control button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 20px;
      line-height: 1;
      padding: 6px 8px;
      user-select: none;
      border-radius: 7px;
      transition: background-color 0.18s, box-shadow 0.18s;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.10);
      width: 40px;
      height: 40px;
      min-width: 0;
      min-height: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .vertical-control button img {
      width: 32px !important;
      height: 32px !important;
      background: white;
      border-radius: 8px;
      box-shadow: 0 0 1.5px rgba(0, 0, 0, 0.07);
      padding: 2px;
      object-fit: contain;
      display: block;
    }

    .vertical-control button:hover {
      background-color: #ededed;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.12);
    }

    .control-label {
      margin-top: 3px;
      font-size: 10px;
      color: #333;
      text-align: center;
      user-select: none;
      line-height: 1.05;
      font-family: inherit;
      white-space: nowrap;
      max-width: 64px;
      word-break: break-word;
      opacity: 0.90;
      pointer-events: none;
      transition: opacity 0.15s;
    }

    .selected-layer {
      filter: drop-shadow(0 0 6px #f00);
    }

    .leaflet-popup-close-button {
      display: none;
    }

    @media (max-width: 520px) {
      .vertical-control {
        padding: 2px 2px;
        gap: 2px;
      }

      .control-item {
        width: 36px;
        min-width: 36px;
      }

      .vertical-control button {
        width: 28px;
        height: 28px;
        font-size: 14px;
        padding: 3px 2px;
      }

      .vertical-control button img {
        width: 18px !important;
        height: 18px !important;
        padding: 0;
      }

      .control-label {
        display: none !important;
      }
    }
  </style>
</head>

<body>

  <div id="map"></div>

  <script>
    const map = L.map('map').setView([45.5236, -122.6750], 13);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
    }).addTo(map);

    // Add search control
    L.Control.geocoder({ defaultMarkGeocode: true }).addTo(map);

    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    // Icons for markers and controls (all L.icon!)
    const fireIcon = L.icon({
      iconUrl: 'icons/fire.png',
      iconSize: [40, 40],
      iconAnchor: [20, 40],
      popupAnchor: [0, -40]
    });
    const droneIcon = L.icon({
      iconUrl: 'icons/drone.png',
      iconSize: [40, 40],
      iconAnchor: [20, 40],
      popupAnchor: [0, -40]
    });
    const fire_stationIcon = L.icon({
      iconUrl: 'icons/fire-station.png',
      iconSize: [40, 40],
      iconAnchor: [20, 40],
      popupAnchor: [0, -40]
    });
    const areaIcon = L.icon({
      iconUrl: 'icons/area.png',
      iconSize: [40, 40],
      iconAnchor: [20, 20],
      popupAnchor: [0, -20]
    });
    const clearIcon = L.icon({
      iconUrl: 'icons/clear.png',
      iconSize: [40, 40],
      iconAnchor: [20, 20],
      popupAnchor: [0, -20]
    });
    const clearAllIcon = L.icon({
      iconUrl: 'icons/clearall.png',
      iconSize: [40, 40],
      iconAnchor: [20, 20],
      popupAnchor: [0, -20]
    });
    const saveIcon = L.icon({
      iconUrl: 'icons/sendb.png',
      iconSize: [40, 40],
      iconAnchor: [20, 20],
      popupAnchor: [0, -20]
    });
    const circleIcon = L.icon({
      iconUrl: 'icons/circle.png',
      iconSize: [16, 16],      // adjust size as needed
      iconAnchor: [8, 8],      // center the icon properly
      popupAnchor: [0, -8]
    });

    let selectedLayer = null;
    let selectedWaypoints = [];

    // Clear selection including polyline and linked waypoint circles
    function clearSelection() {
      if (selectedLayer) {
        if (selectedLayer._icon) {
          selectedLayer._icon.classList.remove('selected-layer');
        } else if (selectedLayer.setStyle) {
          selectedLayer.setStyle({ color: '#353535' });
        }

        // Also clear highlight from associated waypoint circles
        if (selectedWaypoints.length > 0) {
          selectedWaypoints.forEach(circle => {
            if (circle._icon) {
              circle._icon.classList.remove('selected-layer');
            } else if (circle.setStyle) {
              circle.setStyle({ color: '#353535' });
            }
          });
          selectedWaypoints = [];
        }

        selectedLayer = null;
      }
    }

    // When selecting a layer
    function layerSelection(e) {
      clearSelection();
      selectedLayer = e.layer;

      if (selectedLayer._icon) {
        // It's a marker or circle
        selectedLayer._icon.classList.add('selected-layer');
      } else if (selectedLayer.setStyle) {
        selectedLayer.setStyle({ color: 'red' });
      }

      // If this is a waypoint polyline, select its waypoint circles too
      if (selectedLayer._waypointCircles && Array.isArray(selectedLayer._waypointCircles)) {
        selectedWaypoints = selectedLayer._waypointCircles;
        selectedWaypoints.forEach(circle => {
          if (circle._icon) {
            circle._icon.classList.add('selected-layer');
          } else if (circle.setStyle) {
            circle.setStyle({ color: 'red' });
          }
        });
      }
    }


    // Clear selection when clicking on the map but not on any layer
    map.on('click', function (e) {
      clearSelection();
    });

    drawnItems.on('click', function (e) {
      layerSelection(e);
    });

    const VerticalControl = L.Control.extend({
      onAdd: function (map) {
        const container = L.DomUtil.create('div', 'vertical-control leaflet-bar');

        // Controls array uses L.icon for all
        const controls = [
          { name: 'Fire', icon: fireIcon, type: 'marker' },
          { name: 'Drone', icon: droneIcon, type: 'marker' },
          { name: 'Fire station', icon: fire_stationIcon, type: 'marker' },
          { name: 'Area', icon: areaIcon, type: 'area' },
          { name: 'Clear', icon: clearIcon, type: 'clear' },
          { name: 'Clear All', icon: clearAllIcon, type: 'clearAll' },
          { name: 'Save', icon: saveIcon, type: 'save' }
        ];

        let currentDrawHandler = null;
        const ids = {
          Fire: 1,
          Drone: 1,
          'Fire station': 1,
          Area: 1
        };

        function cancelDrawing() {
          if (currentDrawHandler) {
            currentDrawHandler.disable();
            currentDrawHandler = null;
          }
        }

        function addCancelOnEscape() {
          function onKeyDown(e) {
            if (e.key === 'Escape') cancelDrawing();
          }
          document.addEventListener('keydown', onKeyDown, { once: true });
        }

        controls.forEach(({ name, icon, type }) => {
          const item = L.DomUtil.create('div', 'control-item', container);
          const btn = L.DomUtil.create('button', '', item);
          btn.title = name;

          // Render icon using L.icon.options.iconUrl
          const img = document.createElement('img');
          img.src = icon.options.iconUrl;
          btn.appendChild(img);

          btn.onclick = (e) => {
            e.stopPropagation();
            cancelDrawing();

            if (type === 'marker') {
              clearSelection();
              currentDrawHandler = new L.Draw.Marker(map, { icon });
              currentDrawHandler.enable();

              map.once(L.Draw.Event.CREATED, function (e) {
                const layer = e.layer;
                drawnItems.addLayer(layer);

                const count = ids[name]++;
                const label = `${name.toUpperCase()} ${count}`;

                let popupLatLng;
                if (layer.getLatLng) {
                  popupLatLng = layer.getLatLng();
                } else if (layer.getBounds) {
                  popupLatLng = layer.getBounds().getCenter();
                }

                const coordInfo = layer.getLatLng
                  ? `Lat: ${popupLatLng.lat.toFixed(5)}, Lng: ${popupLatLng.lng.toFixed(5)}`
                  : (() => {
                    const bounds = layer.getBounds();
                    const sw = bounds.getSouthWest();
                    const ne = bounds.getNorthEast();
                    return `
                    <b>SW:</b> (${sw.lat.toFixed(5)}, ${sw.lng.toFixed(5)})<br>
                    <b>NE:</b> (${ne.lat.toFixed(5)}, ${ne.lng.toFixed(5)})
                  `;
                  })();

                const defaultPopupContent = `${label}<br>${coordInfo}`;
                const formHtml = `
              <form id="desc-form" style="min-width: 200px;">
                <label for="desc-input"><b>${label}</b> Description (optional):</label><br>
                <textarea id="desc-input" rows="3" style="width: 100%; resize: vertical;"></textarea><br>
                <small>${coordInfo}</small><br>
                <button type="submit" style="margin-top: 6px;">Save</button>
                <button type="button" id="cancel-btn" style="margin-left: 6px;">Cancel</button>
              </form>
            `;

                const popup = L.popup({ closeOnClick: false, autoClose: false })
                  .setLatLng(popupLatLng)
                  .setContent(formHtml)
                  .openOn(map);

                function closePopup() {
                  map.closePopup(popup);
                  document.removeEventListener('click', onDocumentClick, true);
                }

                const form = document.getElementById('desc-form');
                const cancelBtn = document.getElementById('cancel-btn');
                const textarea = document.getElementById('desc-input');
                textarea.focus();

                form.addEventListener('submit', (evt) => {
                  evt.preventDefault();
                  const desc = textarea.value.trim();

                  const fullLabel = desc
                    ? `${label}: ${desc}<br>${coordInfo}`
                    : defaultPopupContent;

                  layer.bindPopup(fullLabel);
                  closePopup();
                });

                cancelBtn.addEventListener('click', () => {
                  layer.bindPopup(defaultPopupContent);
                  closePopup();
                });

                textarea.addEventListener('keydown', (evt) => {
                  if (evt.key === 'Enter' && !evt.shiftKey) {
                    evt.preventDefault();
                    form.requestSubmit();
                  }
                });

                function onDocumentClick(e) {
                  const popupContainer = document.querySelector('.leaflet-popup-content');
                  if (popupContainer && !popupContainer.contains(e.target)) {
                    layer.bindPopup(defaultPopupContent);
                    closePopup();
                  }
                }
                document.addEventListener('click', onDocumentClick, true);

                currentDrawHandler = null;
              });

              addCancelOnEscape();
            }
            else if (type === 'area') {
              clearSelection();
              currentDrawHandler = new L.Draw.Rectangle(map, {
                shapeOptions: {
                  color: '#353535',
                  fillColor: '#353535',
                  fillOpacity: 0.4  // Optional: control fill transparency
                }
              });
              currentDrawHandler.enable();

              map.once(L.Draw.Event.CREATED, function (e) {
                const layer = e.layer;
                drawnItems.addLayer(layer);

                const count = ids[name]++;
                const label = `${name.toUpperCase()} ${count}`;

                let popupLatLng;
                if (layer.getLatLng) {
                  popupLatLng = layer.getLatLng();
                } else if (layer.getBounds) {
                  popupLatLng = layer.getBounds().getCenter();
                }

                const coordInfo = layer.getLatLng
                  ? `Lat: ${popupLatLng.lat.toFixed(5)}, Lng: ${popupLatLng.lng.toFixed(5)}`
                  : (() => {
                    const bounds = layer.getBounds();
                    const sw = bounds.getSouthWest();
                    const ne = bounds.getNorthEast();
                    return `
                    <b>SW:</b> (${sw.lat.toFixed(5)}, ${sw.lng.toFixed(5)})<br>
                    <b>NE:</b> (${ne.lat.toFixed(5)}, ${ne.lng.toFixed(5)})
                  `;
                  })();

                const defaultPopupContent = `${label}<br>${coordInfo}`;
                const formHtml = `
              <form id="desc-form" style="min-width: 200px;">
                <label for="desc-input"><b>${label}</b> Description (optional):</label><br>
                <textarea id="desc-input" rows="3" style="width: 100%; resize: vertical;"></textarea><br>
                <small>${coordInfo}</small><br>
                <button type="submit" style="margin-top: 6px;">Save</button>
                <button type="button" id="cancel-btn" style="margin-left: 6px;">Cancel</button>
              </form>
            `;

                const popup = L.popup({ closeOnClick: false, autoClose: false })
                  .setLatLng(popupLatLng)
                  .setContent(formHtml)
                  .openOn(map);

                function closePopup() {
                  map.closePopup(popup);
                  document.removeEventListener('click', onDocumentClick, true);
                }

                const form = document.getElementById('desc-form');
                const cancelBtn = document.getElementById('cancel-btn');
                const textarea = document.getElementById('desc-input');
                textarea.focus();

                form.addEventListener('submit', (evt) => {
                  evt.preventDefault();
                  const desc = textarea.value.trim();

                  const fullLabel = desc
                    ? `${label}: ${desc}<br>${coordInfo}`
                    : defaultPopupContent;

                  layer.bindPopup(fullLabel);
                  closePopup();
                });

                cancelBtn.addEventListener('click', () => {
                  layer.bindPopup(defaultPopupContent);
                  closePopup();
                });

                textarea.addEventListener('keydown', (evt) => {
                  if (evt.key === 'Enter' && !evt.shiftKey) {
                    evt.preventDefault();
                    form.requestSubmit();
                  }
                });

                function onDocumentClick(e) {
                  const popupContainer = document.querySelector('.leaflet-popup-content');
                  if (popupContainer && !popupContainer.contains(e.target)) {
                    layer.bindPopup(defaultPopupContent);
                    closePopup();
                  }
                }
                document.addEventListener('click', onDocumentClick, true);

                currentDrawHandler = null;
              });

              addCancelOnEscape();
            }
            else if (type === 'clear') {
              if (selectedLayer) {
                drawnItems.removeLayer(selectedLayer);

                // Remove all the selected way points if any
                if (selectedWaypoints.length > 0) {
                  selectedWaypoints.forEach(circle => { drawnItems.removeLayer(circle) });
                  selectedWaypoints = [];
                }

                selectedLayer = null;
              } else {
                const center = map.getCenter();
                const noSelectionPopup = L.popup({
                  closeButton: true,
                  autoClose: true,
                  closeOnClick: true,
                  className: 'custom-popup'
                })
                  .setLatLng(center)
                  .setContent('<b>No shape selected to clear!</b>')
                  .openOn(map);
              }
            }
            else if (type === 'clearAll') {
              drawnItems.clearLayers();
              selectedLayer = null;
              Object.keys(ids).forEach(k => ids[k] = 1);
            }
            else if (type === 'save') {
              clearSelection();
              // extract_map_features_post();

              // const pathList = [
              //   [
              //     { lat: 40.7128, lng: -74.0060 },
              //     { lat: 40.7308, lng: -73.9975 }
              //   ],
              //   [
              //     { lat: 34.0522, lng: -118.2437 },
              //     { lat: 34.0407, lng: -118.2468 }
              //   ],
              //   [
              //     { lat: 51.5074, lng: -0.1278 },
              //     { lat: 51.5155, lng: -0.0922 }
              //   ]
              // ];

              // pathList.forEach(coords => {
              //   drawWaypointPath(coords);
              // });


            }
          };

          // Add label under button
          const label = L.DomUtil.create('span', 'control-label', item);
          label.innerText = name;
        });

        return container;
      }
    });

    const customControl = new VerticalControl();
    map.whenReady(() => {
      customControl.addTo(map);
      const controlEl = document.querySelector('.vertical-control');
      if (controlEl) {
        document.getElementById('map').appendChild(controlEl);
      }
    });

    ////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////
    function extract_map_features_post() {
      const marker = [];
      const rectangle = [];

      drawnItems.eachLayer(layer => {
        let name = '';
        let id = 0;
        let description = '';
        let coordinates = null;

        const popupContent = layer.getPopup() ? layer.getPopup().getContent() : '';
        const nameMatch = popupContent.match(/([A-Z ]+)(\d+)/);
        if (nameMatch) {
          name = nameMatch[1].trim();
          id = parseInt(nameMatch[2]);
        }

        const descMatch = popupContent.match(/:\s*(.*)<br>/);
        description = descMatch ? descMatch[1].trim() : '';

        if (layer instanceof L.Marker) {
          const latlng = layer.getLatLng();
          coordinates = { lat: latlng.lat, lng: latlng.lng };

          marker.push({ name, id, description, coordinates });

        } else if (layer instanceof L.Rectangle) {
          const bounds = layer.getBounds();
          const sw = bounds.getSouthWest();
          const ne = bounds.getNorthEast();

          coordinates = {
            sw: { lat: sw.lat, lng: sw.lng },
            ne: { lat: ne.lat, lng: ne.lng }
          };

          rectangle.push({ name, id, description, coordinates });
        }
      });

      return { rectangle, marker }
    }
    //////////////////////////////////////////////////////////////
    function drawWaypointPath(coordsArray) {
      if (!Array.isArray(coordsArray) || coordsArray.length < 2) {
        console.error("Need at least two coordinates to draw a waypoint path.");
        return;
      }

      const latlngs = coordsArray.map(coord => {
        if (Array.isArray(coord) && coord.length === 2) {
          return L.latLng(coord[0], coord[1]);
        } else if (coord.lat !== undefined && coord.lng !== undefined) {
          return L.latLng(coord.lat, coord.lng);
        } else {
          console.error("Invalid coordinate format:", coord);
          return null;
        }
      }).filter(Boolean);

      // Draw polyline
      const polyline = L.polyline(latlngs, {
        color: '#353535',
        weight: 4,
        opacity: 0.8,
        lineJoin: 'round',
        dashArray: '6, 4'
      }).addTo(drawnItems);

      // Draw waypoint circles and keep references
      const waypointCircles = latlngs.map(latlng => {
        const circle = L.marker(latlng, { icon: circleIcon }).addTo(drawnItems);
        return circle;
      });

      // Link circles with polyline for selection
      polyline._waypointCircles = waypointCircles;

      // Zoom to fit the full route
      map.fitBounds(polyline.getBounds());

      // Add popup summary
      polyline.bindPopup(`<b>WAYPOINT ROUTE</b><br>Points: ${latlngs.length}`).openPopup();
    }

    //////////////////////////////////////////////////////////////////////////

  </script>
</body>

</html>